% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/keys.R
\name{make_keys}
\alias{make_keys}
\alias{set_keys}
\title{Keys}
\usage{
make_keys(x)
}
\arguments{
\item{x}{Input (coerced to a character vector) that will be converted to a
string. See Detials.}
}
\value{
For \code{make_key}, a character vector of \code{length(x)}. For \code{set_keys}, \code{x} but named.
}
\description{
Keys are names that are syntactically valid and unique.
}
\details{
Naming things is hard. By their nature, any naming scheme or
  philosophy is opinionated.

  The philosophy here is focused specifically on producing syntactically
  valid and unique names. The word 'keys' has been adopted to distinguish
  this from the various degrees of syntactic validity and uniqueness that are
  \emph{allowed} within R (even if they are not \emph{recomended}).

  There are a number of very good naming schemes within the R ecosystem.
  Apart from the base-R function \code{\link{make.names}}, high-profile
  examples include the \code{\link[vctrs::vec_as_names]{tidyverse}} and the
  \code{\link[janitor::make_clean_names]{janitor package}}). These functions
  adopt elements from all three.

  The overarching philosophy here is that if a name is syntactically valid
  and unique, then no conversion is performed, however 'ugly' that name might
  be. This is consistent with \code{make.names} and the \code{tidyverse} but
  contrasts the \code{janitor} package, which will alter a valid name.

  If conversion is required, the following logic is applied:

  \itemize{

  \item All input is coerced to a character (\code{as.character()}) and
  missing values (NA) are converted to empty strings ("").

  \item Some 'special' strings are replaced with syntactically valid
  alternatives (see table below).

  \item Non-syntactic characters that appear \strong{before} the first
  letter, number or underscore are replaced by ("filled with") dots.

  \item Non-syntactic characters or separators (or sequences of these) that
  appear \strong{after} this point are replaced with ("collapsed to") a
  single dot OR an underscore.

  \itemize{

  \item Which separator character to use is determined by the input. The
  underscore ("_") character is the default, unless the input string contains
  dots, in which case, a dot is used.

  }

  \item Unless the string is a \link[base::reserved]{reserved word}, trailing
  non-syntactic characters or separators are removed.

  \item Dots are prepended, as needed, so that the start of the string
  syntactically valid.

  \item If the string is a reserved word, or one is created by prior
  modifications then it is prepended by a single dot.

  \item Finally, if values are not unique, they are suffixed with \code{...j} where
  \code{j} is an integer representing the position.

  }

  The \code{tidyverse} 'Ugly, with a purpose' philosophy.

  \tabular{lll}{

  \strong{Item}  \tab  \strong{Replacement}  \tab  \strong{Example}\cr

  "\%"           \tab  "percent"             \tab "\% cover" => "percent_cover"\cr

  "#"            \tab  "number"              \tab "Plants (#) => "plants_number"\cr

  "$"            \tab  "dollar"              \tab "$ Spent" => "dollar_Spent"\cr

  "[x]^2"        \tab  "[x] squared"         \tab "1m^2" => "..1m_squared"\cr

  "[x]^-1"       \tab   "per [x]"            \tab "m s^-1" => "m_per_s"\cr

  "[x]^-2"       \tab   "per [x] squared"    \tab "m^-2" => "per_m_squared"

  }


  Where [x] is any alphanumeric character string
}
